## Introduction
-->This exercise covers the exploitation of a session injection in the Play framework. This issue can be used to tamper with the content of the session while bypassing the signing mechanism
-->This course details the exploitation of a session injection in the Play framework. This issue can be used to inject arbitrary content inside the session and therefore modify the application logic to escalate privileges.

## The Play Framework
-->The [Play Framework](http://www.playframework.com/) is a web framework that allows developers to quickly build web application in Java or Scala. The way the code is organised and the URL are mapped are very similar to Ruby-on-Rails.

## Fingerprinting
-->Here the Play application is deployed on the port 80 and running as root (to be able to bind on the port 80). We can observe that Play is used by looking at the Server header:
```
% echo -ne "HEAD / HTTP/1.1\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | netcat vulnerable 80 HTTP/1.1 200 OKServer: Play! Framework;1.2.5;prodContent-Type: text/html; charset=utf-8Set-Cookie: PLAY_FLASH=;Expires=Sun, 15-Jun-14 21:47:26 GMT;Path=/Set-Cookie: PLAY_ERRORS=;Expires=Sun, 15-Jun-14 21:47:26 GMT;Path=/Set-Cookie: PLAY_SESSION=;Expires=Sun, 15-Jun-14 21:47:26 GMT;Path=/Cache-Control: no-cacheContent-Length: 2179
```
-->**Running Play or any web server that doesn't drop privileges during its startup is obviously a terrible idea. A vulnerability (directory traversal, RCE, ...) in any application hosted will provide the attacker with full server compromise (access to /etc/shadow for directory traversal, running command as root for RCE).**
-->Since we can register an account, we will try to create a test:test1 account to look into the session's handling.
-->After registering this account, we receive the following cookie:
```
PLAY_SESSION=dc76c24ea96cdf0009188367583f07bee1126aff-%00___AT%3A103939fbeba60071e96c5dd505a7916d8b49c9c9%00%00user%3Atest%00
```
-->We can see that information is stored in clear text in the session: user%3atest (user:test). Unfortunately, no sensitive information is stored as part of the session.

## Play session
-->The session mechanism used by Play is really similar to Rack sessions (used by Ruby-on-Rails by default). The content of the session is sent back to the clients instead of being stored server side. To prevent an attacker from tampering his session. A signature of the session is calculated. We will now dive into this mechanism by reviewing the code involved in this bug.
-->This mechanism is used to easily load-balance requests between multiple servers without keeping a central sessions' pool shared between the multiple servers. By sharing the key used to sign the session, any servers with the key can edit and trust the content of the session.
-->Since this vulnerability has been discovered ([http://www.playframework.com/security/vulnerability/20130806-SessionInjection](http://www.playframework.com/security/vulnerability/20130806-SessionInjection)), the session management has been fully rewritten and does not use this format anymore.
-->We will now see how the sessions mechanism worked before the vulnerability was reported.

## White Box approach
-->If we look at how sessions were handled ([https://github.com/playframework/play1/blob/1.2.5/framework/src/play/mvc/Scope.java](https://github.com/playframework/play1/blob/1.2.5/framework/src/play/mvc/Scope.java)):
```java
	static Pattern sessionParser = Pattern.compile("\u0000([^:]*):([^\u0000]*)\u0000");
	[...]
	static Session restore() {
	  try {
	    Session session = new Session();
	    Http.Cookie cookie = Http.Request.current().cookies.get(COOKIE_PREFIX + "_SESSION");
	    final int duration = Time.parseDuration(COOKIE_EXPIRE) ;
	    final long expiration = (duration * 1000l);
	    if (cookie != null && Play.started && cookie.value != null && !cookie.value.trim().equals("")) {
	      String value = cookie.value;
	      int firstDashIndex = value.indexOf("-");
	      if(firstDashIndex > -1) {
	        String sign = value.substring(0, firstDashIndex);
	        String data = value.substring(firstDashIndex + 1);
	        if (sign.equals(Crypto.sign(data, Play.secretKey.getBytes()))) {
	          String sessionData = URLDecoder.decode(data, "utf-8");
	          Matcher matcher = sessionParser.matcher(sessionData);
	          while (matcher.find()) {
	              session.put(matcher.group(1), matcher.group(2));
	          }
	        }
	      }
	   [...]
```
-->First, the code retrieve the cookie used for the session, for example PLAY_SESSION. If the cookie is present it will then split it into 2 parts:
-   sign: the signature.
-   data: the data.
-->It will then verify the signature using the method Crypto.sign and the secret key Play.secretKey.
-->The Play.secretKey is stored in conf/application.conf, if you can get access to this file (for example using a directory traversal), you will be able to forge sessions.
-->We can see that the session's signature is based on HMAC (the code is available in Crypto.java https://github.com/playframework/play1/blob/1.2.5/framework/src/play/libs/Crypto.java) as we can see in the code below:
```
public static String sign(String message, byte[] key) {
	  if (key.length == 0) {
	      return message;
	  }
	 
	  try {
	      Mac mac = Mac.getInstance("HmacSHA1");
```
-->Using HMAC will prevent attacks like length extension attacks ([https://en.wikipedia.org/wiki/Length_extension_attack](https://en.wikipedia.org/wiki/Length_extension_attack)), as opposed to using simple hash functions (like MD5 for example).
-->We can also see that the code in Scope.java used a non time-constant string comparison:
```
if (sign.equals(Crypto.sign(data, Play.secretKey.getBytes()))) {
```
-->This issue could potentially be exploited to create a valid signature using brute-force by comparing the time used to compare the signature provided to the one generated. It is pretty unlikely to be exploited due to network latency and the computing of the signature but the same issue has been fixed in Ruby-on-Rails in early 2013...
-->Also, as with most (all?) session mechanisms that send back a signed cookie to the client, the session cannot be immediately invalidated since an attacker will still be able to use the old session even if a new empty one has been sent to him.
-->Once the signature is verified, Play parses the session's data using the following mechanism:
```
	static Pattern sessionParser = Pattern.compile("\u0000([^:]*):([^\u0000]*)\u0000");
	[...]
	  Matcher matcher = sessionParser.matcher(sessionData);
	  while (matcher.find()) {
	      session.put(matcher.group(1), matcher.group(2));
	  }
```
-->If you have already look in the sessions parsing of few web frameworks, you quickly realise that this mechanism is fairly different to a lot of frameworks. Most framework will rely on known formats (like YAML, JSON, object serialisation) to store session's information. Here the data is only split using a regular expression and a loop.
-->Let's now see how information is added to the server side session:
```
	public void put(String key, String value) {
	  if (key.contains(":")) {
	    throw new IllegalArgumentException("Character ':' is invalid in a session key.");
	  }
	  change();
	  if (value == null) {
	     data.remove(key);
	  } else {
	     data.put(key, value);
	  }
	}
```
-->We can see here that we can't use a key that contains a :. However nothing prevent a value from containing a NULL Byte. If an attacker is able to inject NULL Bytes in a value (for example in his/her username), they can potentially inject additional variables inside the session (without knowing the secret key used for the signature).

## Black Box approach
-->In a Black Box approach, you would have to find that the delimiter is an encoded NULL byte and try to inject one in your username to see what happens. By using trial and error, you should be able to find the same bug.

-->--------iinim enthello ind namuk video explanation ilek kadakam

# Video Explanation
## Video 1 - Play session injection introduction
-->play framework is a MVC (Model View Controller) framework similar to Rails that supports java and scala
-->it is used by many big companies
-->ee play session il main aayi rand karyaman ullath ie, data and signature. data ennal namude user credentials and signature ennath namude jwt oke pole. so signature sign chyan ulla secret key areelengil ee session decode chyan patila ok
->key1:value | key2:value | key3:value  --- inagne aan format
```
>>key1:value | key2:value | key3:value  --- inagne aan format
>>ith server nokumbol :
ie, %00key1:value%00%00key2:value%00%00key3:value%00 
>> ingane varum.so namal evide aan inject chyendathenal :
>> key1:[inject] | key2:value | key3:value  --- so :
>> key1:value%00%00key4:value4 | key2:value | key3:value  -- enn varum
```
-->application nte logic anusarich 3 session ullu.but namal ivide 4 oru session undaki. so application ath process chyumbol 4 session aayi marum ok

## Video 2 - play session exploitation
-->so lab open chyuka enit regitser il poi register chyanam.username:test, passwd:test kodukuka
-->ini burp proxil vann nokiyal kanam namuk puthiya session cookie kiteetind
```http
Set-Cookie: PLAY_SESSION=340a6f101789485f178b0734937cf205b154f3eb-%00___AT%3Ac97b2cf67957e5d865ed123438ba2b6513ba7a40%00%00user%3Atest%00;Path=/
```
-->ith analyse chythal manasilakum rand karyangal ithil und first kanuna kore numbers ennath signature aan.randamath kanunathan data.athil namude username und ie, test
-->so ee signatur ile aayalum or data yile aayalum namal enthengilum modify chythal play framework reject chyum.so ee session namuk edit chyanengil namude kayil signature sign chyan ulla secret key arinjirikanam ok
-->ini ee session il nokiyal kanam kore null bytes.so ith analyse chythal manasilakan patum session ullath key:value enna formate il aan ie
```
%00__AT:c97b2cf67957e5d865ed123438ba2b6513ba7a40  --signature
%00user:test%00                                   --data
```
-->ivide `__AT and USER ann` key and athinte values aan format ile value ok
-->null bytes ennath oro key inem seperate chyuna seperators aan
-->null bytes vech test chyubmbol browser il chyaruth repeater il chyanam
-->ini namuk puthiya oru accoutn repeater il undakam.so /register edukuka enit username=test ennath  username=test2%00  enn kodukuka. ini namuk kituna response ile cookie nokiyal kanam : 
```http
Set-Cookie: PLAY_SESSION=2b8e299cecefa3e67f4d0da93965bb6cf26012bb-%00___AT%3Ac97b2cf67957e5d865ed123438ba2b6513ba7a40%00%00user%3Atest2%00%00;Path=/
```
-->ivide data nokiyal kanam test2%00%00  enn. ie, mumbathe session il last oru %00 undayirunulu.but ivide koodi. ie, namuk null bytes inject chyan patum.application ee inject chyuna null byte filter chyunila
-->so namuk ini ingane inject chyth admin aayi maran nokam ok
-->so ivide format key:value ennan so admin=true ennakan admin:1  enn kodukanam.athpole user admin aakan user:admin enn kodukanam.already test enn adyam ullath karyamakenda.randamath user key varunathan applicaiton nokunath so namuk puthiya username undakam ie username=test2%00 ennath mati :
```
>>repeateril aan chyenath allathe browser il chyaruth
&username=test3%00%00admin:1%00%00user:admin1%00%00&password=test
```
inagane username kodukuka enit send adikuka.apol namuk kituna response il 302 found enn kanich namuk puthiya cookie kitum :
```r
Set-Cookie: PLAY_SESSION=3ca154c687ea618e964cdb34c72d821a4c5889b8-%00___AT%3Ac97b2cf67957e5d865ed123438ba2b6513ba7a40%00%00user%3Atest3%00%00admin%3A1%00%00user%3Aadmin1%00%00%00;Path=/
```
ee cookie copy chyth namude browser il ulla cookie replace chythal namal admin aayi maru.avide vech namuk lab complete chyan ulla key kitum