## Introduction
-->This course details the exploitation of an insecure OAuth2 Authorization Server that allows a malicious user to trick a victim to gain access to his/her account.
-->OAuth2 is incredibly hard to get right that's why being able to find holes in implementations is so important.

## The vulnerability
-->This vulnerability here is a simple Cross-Site Scripting vulnerability in the Authorization Server. The page used by users to authorise an application is vulnerable to an XSS.
-->When a user authorizes an application, two steps happen:
1.  The user visits a page with details on the application and the scope of the authorization.
2.  The user authorizes the application.
-->The second step is done via a POST request and is protected against CSRF. The XSS in this page will allow us to bypass the CSRF protection.

## Exploitation
-->To exploit this vulnerability, you will need to register an account and create an OAuth application. Make sure you set the redirect URL to your server and save the client ID and secret.
-->By clicking on the Authorize button, you should get access to the form used to authorize the application. This is where you will need to find the XSS.
-->Once you setup your web server and have the malicious URL that automatically authorizes your application (by submitting the form automatically), you need to get the victim to visit your malicious URL.
-->After visiting the malicious page, the victim should be redirected back to your page (thanks to the redirect URI), and you should get a code. You can use this code along with your secret and client id to get a token. For example, if you use Ruby and the gem oauth2, the following code allows you to get a token:
```ruby
require 'oauth2'
	 
	callback = "[CALLBACK_URL]"
	app_id = "[APPLICATION_ID]"
	 
	secret = "[SECRET]"
	client = OAuth2::Client.new(app_id, secret, site: "[AUTHORIZATION_SERVER]")
	client.auth_code.authorize_url(redirect_uri: callback)
	 
	 
	code="[CODE]"
	access = client.auth_code.get_token( code, redirect_uri: callback)
	access.get("/api/user").parsed
	 
	puts access.token  
```
-->Finally, you can use the token to access the resource server and get the key for this challenge using the following curl command:
```bash
curl -H 'Authorization: Bearer [TOKEN]' [RESOURCE_SERVER]/api/keys --dump-header -
```
-->If the victim authorizes your application, you need to be quick to get and use the code and token. If you wait too long, you may need to restart from scratch with a new application.

## Conclusion
-->This exercise showed you how to exploit a vulnerability in an OAuth2 implementation impacting the Authorization Server. With more and more enterprises using OAuth2, it's important to ensure that this kind of mistakes gets detected and fixed before they get exploited.

# Video Explanation
## Video 1 introduction
-->The attack :
- Create a malicious OAuth2 client with a xss in the client name
- Get the victim to authorise your client automatically via the xss
- The victim leaks their code to you
- Finish the OAuth2 dance with the victims code

## Video 2 exploitation
-->ivide namuk thane oru application undakan ulla option und.so athin name um karyangal oke koduthit ini ath use chyumbol athintethaya oauth2 authorisation pop namuk kitum.
-->so namal athinte name kodukuna sthalath `<h1>test</h1>`  enn koduth save chythit onukoode OAuth2 pop up nokumbol kanam html injection aayitund.so ini ath mati `<script>alert(9)</script>`  kodukumbol namuk xss aakunund.so athan ivide exploit chyunath.athin ivide ruby il script chythan chyunath. molil athinte oru rough script und.athil karyangal replace chyth venam chyan.but njan ee lab complete chyunila.veruthe pranth