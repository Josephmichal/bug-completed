Make sure you finish the following exercises before starting this one: [JWT VIII](http://pentesterlab.com/exercises/jwt_viii/) and [CVE-2018-0114](https://pentesterlab.com/exercises/cve-2018-0114/).

## Introduction
-->Make sure you finish the following exercises before starting this one: [JWT VIII](http://pentesterlab.com/exercises/jwt_viii/) and [CVE-2018-0114](https://pentesterlab.com/exercises/cve-2018-0114/).
-->In this exercise, we are going to cover the jku header in JWT tokens, specifically, we are going to forge a token to become admin.
-->As you learnt in [JWT VIII](http://pentesterlab.com/exercises/jwt_viii/), JWT allows users to link to a public key (using the jku header) inside the header of the token.
-->However, the application should never trust this URL, as an attacker can provide their own URL and sign the message using the corresponding private key.
-->The format we will need to follow to get the right JWK file is very similar to the challenge: [CVE-2018-0114](https://pentesterlab.com/exercises/cve-2018-0114/) and can be inferred from the URL in the token issued by the application ( or [https://www.pentesterlab.com/.well-known/jwks.json](https://www.pentesterlab.com/.well-known/jwks.json)). If you solve [JWT VIII](http://pentesterlab.com/exercises/jwt_viii/), you can use the same file.
-->This time, the URLs allowed for the JWK retrieval have been restricted.
-->However, we can use a file upload functionality to get our JWK file on the same server and bypass the restriction (since our malicious URL will start with the URL of the vulnerable application).

## Building our exploit
-->If you finished the previous JWT exercises, you should already have multiple scripts to play with JWT tokens.
-->Here we will need to do four things:
-   Create a private and public key and create the matching JWK file (in JSON format)
-   Upload the JSON file
-   Build the header with the link to the JSON file we just uploaded.
-   Sign the token using RSA with the private key that matches the n and e in the JWK file we just uploaded.
-->First, you can create a private RSA key using openssl.
-->Once the key is created, to keep things easier, you can build two scripts:
-   One to extract n and e from the private key you just created and populate your JWK file.
-   One to sign your payload using the same private key.
- 
-->However, there are some pitfalls you may run into:
-   You need to change the n and e values in your hosted file (based on the example) to make sure they match the private key you're using.
-   The application caches the URL, but it shouldn't be an issue as you need to upload a new file if you change the key.
-   The application checks that the URL starts with: http://[HOSTNAME]/.well-known/ with [HOSTNAME] being the hostname of the challenge.
-   You need to make sure the algorithm alg is the one you're using to sign. Most likely you will need to change the value to RS256.

## Conclusion
-->This exercise showed you how you can use the jku header to get the application to download a public key from a file you uploaded on the same server (or any server allowed in the restricted list of trusted servers).
-->This allows you to bypass the restriction in place.
-->The challenge also showed you that even if the payload is signed, there may be a way to bypass the signature mechanism.